### 前端渲染方案

 #### CSR

 CSR客户端渲染，浏览器加载html，执行js根据虚拟DOM生成真实dom渲染页面。

![image-20210306161531841](C:\Users\wenbo\AppData\Roaming\Typora\typora-user-images\image-20210306161531841.png)

#### SSR

 在服务器端完成html的数据装载，直接返回浏览器完整的html

#### 同构

代码在服务器端与客户端执行两次，服务器端将html返回给浏览器，浏览器端对DOM完成事件绑定，并且与渲染的DOM进行对比，如果不一样则重新执行渲染。

#### 为什么需要服务端渲染？





![preview](https://pic2.zhimg.com/v2-1983553e404e402fb4aa8212454ebe4d_r.jpg)

#### CSR问题

* SER爬虫不友好

  > 搜索引擎爬虫主要是对html标签进行分析，虽然google有针对js的技术但似乎是也不太聪明。

* 首屏加载时间长

* 浏览器兼容

### SSR问题

* 维护成本高
* 减少白屏时间
* 占用服务器资源

> 首屏幕（服务端渲染）其他页面（客户端渲染）

### 搭建SSR+同构项目



#### 路由同构

* HashRouter

  在客户端渲染中经常使用的是 `react-router-dom `  中的  `HashRouter` 主机域名后面带`/#/`， react 通过监听`hash`值的改变，渲染DOM。`hash` 值改变不会导致浏览器页面重新加载刷新，也就不会向域名发起`get`请求。

* BrowserRouter

  与`hashRouter`不同，没有`/#/`,地址直接是 `127.0.0.1/home`,在页面点击切换路由浏览器也不重新刷新页面重载，但是一旦手动刷新页面直接访问路由，则会返回 找不到资源错误，是因为开发环境下的服务器并没配置相对应的地址的资源。可以在webpack配置中`devServer.historyApiFallback = true` 可以解决。

* StaticRouter

  静态路由用作服务端渲染的路由

  ![image-20210307225418410](C:\Users\wenbo\AppData\Roaming\Typora\typora-user-images\image-20210307225418410.png)

  客户端入口路由配置

  ```javascript
  const App = () => {
    const initialState = (window as any).__INITIAL_STATE__ ;
    const store = createStore(initialState)
    return <Provider store={store}>
      <BrowserRouter>
          {renderRoutes(router)}
      </BrowserRouter>
    </Provider>
  }
  const createApp = () => App()
  ```

  服务端入口路由配置

  ```javascript
  const createApp = (context: any, url: any, store: any) => {
    return <Provider store={store}> <StaticRouter context={context} location={url}>
      <div>
        {renderRoutes(router)}
      </div>
    </StaticRouter>
    </Provider>
  }
  ```

  并且在服务端渲染页面的时候将请求上下文，请求地址，传递给 `StaticRouter`

  ![image-20210307230118454](C:\Users\wenbo\AppData\Roaming\Typora\typora-user-images\image-20210307230118454.png)

#### 状态同构



#### 事件同构

##### 客户端

客户端使用`hydrate`方法渲染DOM，`注水`操作，给服务端返回的DOM绑定事件，以及对比服务端渲染和客户端渲染的DOM内容，如果有不同则做局部替换。

![image-20210307215535412](C:\Users\wenbo\AppData\Roaming\Typora\typora-user-images\image-20210307215535412.png)

```javascript
 ReactDOM.hydrate(createApp(Root), document.getElementById("app"));
```

##### 服务端

* renderToString

服务端使用`renderToString`方法，将React 元素渲染为HTML，返回一个HTML字符串。该方法是同步生产HTML，如果页面过于庞大，HTML结构复杂，则会非常耗时。

![image-20210307220518030](C:\Users\wenbo\AppData\Roaming\Typora\typora-user-images\image-20210307220518030.png)

* renderToNodeStream

将一个 React 元素渲染成其初始 HTML。返回一个可输出 HTML 字符串的[可读流](https://nodejs.org/api/stream.html#stream_readable_streams)。通过可读流输出的 HTML 完全等同于 [`ReactDOMServer.renderToString`](https://react.docschina.org/docs/react-dom-server.html#rendertostring) 返回的 HTML。服务器将`可读流`传给客户端，不用等到HTML全部生成，解析多少内容就传递给浏览器多少内容，大大加快了渲染速度

以下两个方法分别与上面两个方法类似，区别就是不生成额外的DOM属性 `data-reactroot`

* renderToStaticMarkup

* renderToStaticNodeStream

#### CSS样式

#### 执行环境



##### 开发环境

由于在开发环境下webpack将编译完成的文件存储到`内存文件系统`中，便于快速的读取文件，所以在开发环境需要结合`webpack-dev-server` `webpack-dev-middlerware` `webpack-hot-middlerware` 插件配合完成页面的热更新，实现不用刷新浏览器从而更新DOM



##### 生产环境

直接在静态文件目录中读取所需要的bundle和mainfest.json



